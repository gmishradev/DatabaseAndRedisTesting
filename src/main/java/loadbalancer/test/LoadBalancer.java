package loadbalancer.test;
import com.sun.net.httpserver.HttpExchange;
import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.Random;

public class LoadBalancer {
    private final List<ApplicationServer> servers;
    private final String schedulingAlgorithm;
    private int currentServerIndex = 0;

    public LoadBalancer(List<ApplicationServer> servers, String schedulingAlgorithm) {
        this.servers = servers;
        this.schedulingAlgorithm = schedulingAlgorithm;
    }

    public void routeRequest(HttpExchange exchange) throws IOException {
        ApplicationServer server;
        switch (schedulingAlgorithm) {
            case "ROUND_ROBIN":
                server = roundRobin();
                break;
            case "LEAST_CONNECTIONS":
                server = leastConnections();
                break;
            case "RANDOM":
                server = randomSelection();
                break;
            default:
                throw new IllegalArgumentException("Unsupported scheduling algorithm");
        }
      //  System.out.println("Routing request to " + server.getName() + " on port " + server.getPort());

        // Forward the request to the selected application server (make an HTTP request to the server's port)
        sendRequestToServer(server, exchange);
    }

    private void forwardRequestToServer(ApplicationServer server, HttpExchange exchange) throws IOException {
        // Simulate the request forwarding by calling the application server directly (this would be a real HTTP request in production)
        // Create a new HttpExchange instance with the response generated by the application server

        // Prepare the response from the server (this is where you'd do the actual HTTP forwarding in production)
        String response = "Forwarded from Load Balancer: " + server.getName() + " (port " + server.getPort() + ")";

        // Send the response back to the client
        exchange.getResponseHeaders().set("Content-Type", "text/plain");
        exchange.sendResponseHeaders(200, response.getBytes().length);
        OutputStream os = exchange.getResponseBody();
        os.write(response.getBytes());
        os.close();
    }

    private void sendRequestToServer(ApplicationServer server, HttpExchange exchange) throws IOException {
        // In a real scenario, here we would forward the HTTP request to the application server running on its port
        String serverUrl = "http://localhost:" + server.getPort() + "/";
        // Simulate a forwarding mechanism (you can replace this with an actual HTTP client call in a real system)
        // For now, we just simulate a response
        server.handleRequest(exchange); // Direct call for simulation
    }

    private ApplicationServer roundRobin() {
        ApplicationServer server = servers.get(currentServerIndex);
        currentServerIndex = (currentServerIndex + 1) % servers.size();
        return server;
    }

    private ApplicationServer leastConnections() {
        return servers.stream()
                .min((s1, s2) -> Integer.compare(s1.getActiveConnections(), s2.getActiveConnections()))
                .orElseThrow(() -> new IllegalStateException("No servers available"));
    }

    private ApplicationServer randomSelection() {
        Random random = new Random();
        return servers.get(random.nextInt(servers.size()));
    }
}
